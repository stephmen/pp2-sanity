import React, { createContext, useContext, useMemo, useState, useCallback, useEffect, useRef } from 'react';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import classNames from 'classnames';
import schema from 'part:@sanity/base/schema';
import SanityPreview from 'part:@sanity/base/preview';
import { nanoid } from 'nanoid';
import { useToast, MenuButton, Label, Menu, MenuItem, MenuDivider, Dialog, Button, Checkbox, Badge, Select } from '@sanity/ui';
import { ResetIcon, UnpublishIcon, PublishIcon, TrashIcon, SyncIcon, ControlsIcon, SpinnerIcon, EllipsisVerticalIcon, ArrowRightIcon, ChevronLeftIcon, ChevronRightIcon } from '@sanity/icons';
import _client from 'part:@sanity/base/client';
import { ErrorBoundary } from 'react-error-boundary';
import { tap, debounceTime } from 'rxjs/operators';

const RouterContext = /*#__PURE__*/createContext(null); // https://github.com/sanity-io/demo-custom-workflow/blob/d00b0f73fbf8543724772802749bd846078075d6/app/lib/router/internalRouterContextTypeCheck.js#L1

function internalRouterContextTypeCheck(context, propName, componentName) {
  if (!context.__internalRouter) {
    throw new Error('The router is accessed outside the context of a <RouterProvider>.' + ' No router state will be accessible and links will not go anywhere. To fix this,' + ` make sure ${componentName} is rendered in the context of a <RouterProvider /> element`);
  }
} // https://github.com/sanity-io/demo-custom-workflow/blob/d00b0f73fbf8543724772802749bd846078075d6/app/lib/router/provider.js


class RouterProvider extends React.Component {
  render() {
    const router = this.context.__internalRouter;
    return /*#__PURE__*/React.createElement(RouterContext.Provider, {
      value: router
    }, this.props.children);
  }

}

_defineProperty(RouterProvider, "contextTypes", {
  __internalRouter: internalRouterContextTypeCheck
});

function useRouter() {
  return useContext(RouterContext);
}

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$3 = ".styles-module_content__vEeY6 {\n  padding: 0 1rem;\n}\n\n.styles-module_footer__1SDx0 {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  justify-content: flex-end;\n  padding: 0.5rem;\n}\n";
var styles$3 = {"content":"styles-module_content__vEeY6","footer":"styles-module_footer__1SDx0"};
styleInject(css_248z$3);

const client$1 = _client;

const ErroredDocuments = ({
  e,
  schemaType
}) => {
  const idsWithErrors = 'details' in e ? e.details.items.map(item => item.error.id) : [];

  if (!idsWithErrors.length) {
    return null;
  }

  const plural = idsWithErrors.length !== 1;
  return /*#__PURE__*/React.createElement(ErrorBoundary, {
    fallback: null
  }, /*#__PURE__*/React.createElement("p", null, "Please unselect ", plural ? 'these' : 'this', " document", plural ? 's' : '', ' ', "and try again:"), /*#__PURE__*/React.createElement("p", null, idsWithErrors.map(id => /*#__PURE__*/React.createElement(SanityPreview, {
    type: schemaType,
    key: id,
    value: {
      _id: id,
      _type: 'movie'
    }
  }))));
};

const removeDraftPrefix$1 = s => s.startsWith('drafts.') ? s.substring('drafts.'.length) : s;

function BulkActionsMenu({
  className,
  selectedIds,
  typeName
}) {
  const buttonId = useMemo(nanoid, []);
  const schemaType = useMemo(() => schema.get(typeName), [typeName]);
  const toast = useToast();
  const dialogId = useMemo(nanoid, []);
  const [dialogMode, setDialogMode] = useState(null);
  const [loading, setLoading] = useState(false);

  const handleDiscardChanges = async () => {
    setLoading(true);

    try {
      const ids = await client$1.fetch('*[_id in $ids]._id', {
        ids: Array.from(selectedIds).map(id => [id, `drafts.${id}`]).flat()
      });
      const idSet = ids.reduce((set, id) => {
        set.add(id);
        return set;
      }, new Set());
      const draftIdsThatAlsoHavePublishedIds = ids.filter(id => id.startsWith('drafts.') && idSet.has(id.substring('drafts.'.length)));
      const t = client$1.transaction();

      for (const id of draftIdsThatAlsoHavePublishedIds) {
        t.delete(id);
      }

      await t.commit();
      setDialogMode(null);
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Discarding Changes',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk discard changes failed."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setLoading(false);
    }
  };

  const handleUnpublish = async () => {
    setLoading(true);

    try {
      const publishedDocuments = await client$1.fetch('*[_id in $ids]', {
        ids: Array.from(selectedIds)
      });
      const t = client$1.transaction();

      for (const publishedDocument of publishedDocuments) {
        t.createIfNotExists({ ...publishedDocument,
          _id: `drafts.${publishedDocument._id}`,
          _updatedAt: new Date().toISOString()
        });
        t.delete(publishedDocument._id);
      }

      await t.commit();
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Unpublishing',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk unpublished failed. This usually occurs because there are other documents referencing the documents you\u2019re trying to unpublish."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setDialogMode(null);
      setLoading(false);
    }
  };

  const handlePublish = async () => {
    setLoading(true);

    try {
      const draftDocuments = await client$1.fetch('*[_id in $ids]', {
        ids: Array.from(selectedIds).map(id => `drafts.${id}`)
      });
      const t = client$1.transaction();

      for (const draftDocument of draftDocuments) {
        t.createOrReplace({ ...draftDocument,
          _id: removeDraftPrefix$1(draftDocument._id),
          _updatedAt: new Date().toISOString()
        });
        t.delete(draftDocument._id);
      }

      await t.commit();
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Publishing',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk publish failed."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setDialogMode(null);
      setLoading(false);
    }
  };

  const handleDelete = async () => {
    setLoading(true);

    try {
      const idsToDelete = await client$1.fetch('*[_id in $ids]._id', {
        ids: Array.from(selectedIds).map(id => [id, `drafts.${id}`]).flat()
      });
      const t = client$1.transaction();

      for (const id of idsToDelete) {
        t.delete(id);
      }

      await t.commit();
    } catch (e) {
      console.warn(e);
      toast.push({
        title: 'Error Bulk Deleting',
        description: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("p", null, "The bulk delete failed. This usually occurs because there are other documents referencing the documents you\u2019re trying to delete."), /*#__PURE__*/React.createElement(ErroredDocuments, {
          e: e,
          schemaType: schemaType
        })),
        status: 'error',
        closable: true,
        duration: 30 * 1000
      });
    } finally {
      setDialogMode(null);
      setLoading(false);
    }
  };

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MenuButton, {
    button: /*#__PURE__*/React.createElement("button", {
      className: className
    }, /*#__PURE__*/React.createElement(Label, null, "Bulk Actions")),
    portal: true,
    id: buttonId,
    menu: /*#__PURE__*/React.createElement(Menu, {
      style: {
        textAlign: 'left'
      }
    }, /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      text: "Discard changes",
      icon: ResetIcon,
      onClick: () => setDialogMode('discard_changes')
    }), /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      text: "Unpublish",
      icon: UnpublishIcon,
      onClick: () => setDialogMode('unpublish')
    }), /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      text: "Publish",
      icon: PublishIcon,
      onClick: () => setDialogMode('publish')
    }), /*#__PURE__*/React.createElement(MenuDivider, null), /*#__PURE__*/React.createElement(MenuItem, {
      className: "prevent-nav",
      tone: "critical",
      icon: TrashIcon,
      text: "Delete",
      onClick: () => setDialogMode('delete')
    })),
    placement: "bottom"
  }), dialogMode === 'discard_changes' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Discard Changes"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$3.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Discard Changes",
      tone: "critical",
      mode: "ghost",
      disabled: loading,
      onClick: handleDiscardChanges
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$3.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to discard changes to", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "Discarding changes reverts changes made to any drafts of the selected documents and restores the currently published versions."), /*#__PURE__*/React.createElement("p", null, "You can use the", ' ', /*#__PURE__*/React.createElement("a", {
    href: "https://www.sanity.io/docs/history-experience",
    target: "_blank",
    rel: "noreferrer noopener"
  }, "document history"), ' ', "of each individual document to track these changes."))), dialogMode === 'unpublish' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Unpublish Documents"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$3.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Unpublish Documents",
      tone: "critical",
      mode: "ghost",
      disabled: loading,
      onClick: handleUnpublish
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$3.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to unpublish", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "If you unpublish a document, it will no longer be available to the public. Its contents will be moved into a draft if a draft does not already exist. From there you can continue to author the document and re-publish it later."), /*#__PURE__*/React.createElement("p", null, "You can use the", ' ', /*#__PURE__*/React.createElement("a", {
    href: "https://www.sanity.io/docs/history-experience",
    target: "_blank",
    rel: "noreferrer noopener"
  }, "document history"), ' ', "of each individual document to track these changes."))), dialogMode === 'publish' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Publish Documents"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$3.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Publish Documents",
      tone: "positive",
      disabled: loading,
      onClick: handlePublish
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$3.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to publish", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "Publishing a document makes the current contents of each document publicly available."), /*#__PURE__*/React.createElement("p", null, "You can use the", ' ', /*#__PURE__*/React.createElement("a", {
    href: "https://www.sanity.io/docs/history-experience",
    target: "_blank",
    rel: "noreferrer noopener"
  }, "document history"), ' ', "of each individual document to track these changes."))), dialogMode === 'delete' && /*#__PURE__*/React.createElement(Dialog, {
    id: dialogId,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Delete Documents"),
    zOffset: 100000,
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$3.footer
    }, /*#__PURE__*/React.createElement(Button, {
      text: "Cancel",
      mode: "ghost",
      disabled: loading,
      onClick: () => setDialogMode(null)
    }), /*#__PURE__*/React.createElement(Button, {
      text: "Delete Documents",
      tone: "critical",
      disabled: loading,
      onClick: handleDelete
    })),
    onClose: () => setDialogMode(null)
  }, /*#__PURE__*/React.createElement("div", {
    className: styles$3.content
  }, /*#__PURE__*/React.createElement("p", null, "Are you sure you want to delete", ' ', /*#__PURE__*/React.createElement("strong", null, selectedIds.size), " document", selectedIds.size === 1 ? '' : 's', "?"), /*#__PURE__*/React.createElement("p", null, "Deleting a document makes it no longer available to the public as well as removing any draft versions of it."), /*#__PURE__*/React.createElement("p", null, /*#__PURE__*/React.createElement("strong", null, "Note:"), " in order to delete a document, it must not be referenced by any other document. You may have to remove those references first."))));
}

function createEmitter() {
  const listeners = new Set();

  function subscribe(listener) {
    listeners.add(listener);

    const unsubscribe = () => {
      listeners.delete(listener);
    };

    return unsubscribe;
  }

  function notify() {
    for (const listener of listeners) {
      listener();
    }
  }

  return {
    subscribe,
    notify
  };
}

const client = _client;

const removeDraftPrefix = s => s.startsWith('drafts.') ? s.substring('drafts.'.length) : s;

function usePaginatedClient({
  typeName,
  pageSize,
  selectedColumns
}) {
  // the loading statuses are a set of strings
  // when it's empty, nothing is loading
  const [loadingStatuses, setLoadingStatuses] = useState(new Set());
  const loading = loadingStatuses.size > 0; // stores the state for the total amount of de-duped documents

  const [total, setTotal] = useState(0); // uses the pageSize to calculate the total pages

  const totalPages = Math.ceil(total / pageSize); // stores the current set of active IDs on the page.
  // these are fed into the `useEffect` that creates the `results` state

  const [pageIds, setPageIds] = useState([]); // the current page. changing this will trigger a re-fetch of the `pageIds`

  const [page, setPage] = useState(0); // the current result set

  const [results, setResults] = useState([]); // used to force refresh. TODO: consider refactoring this

  const [refreshId, setRefreshId] = useState(nanoid());
  const refresh = useCallback(() => setRefreshId(nanoid()), []); // get total count

  useEffect(() => {
    let canceled = false;

    async function getTotalCount() {
      // add the `total_count` to the loading statuses
      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('total_count');
        return next;
      }); // fetch all the draft IDs in this document type

      const draftIds = await client.fetch(`*[_type == $typeName && _id in path("drafts.**")]._id`, {
        typeName
      });
      const {
        draftsWithPublishedVersion,
        notDraftCount
      } = await client.fetch(`{
          "draftsWithPublishedVersion": *[_type == $typeName && _id in $ids]._id,
          "notDraftCount": count(*[_type == $typeName && !(_id in path("drafts.**"))]),
        }`, {
        ids: draftIds.map(removeDraftPrefix),
        typeName
      }); // the calculation for the total is then:

      const total = draftIds.length - draftsWithPublishedVersion.length + notDraftCount; // early return on canceled

      if (canceled) return; // remove `total_count` from the loading statuses

      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.delete('total_count');
        return next;
      });
      setTotal(total);
    }

    getTotalCount().catch(e => {
      // TODO: proper error handling
      console.warn(e);
    });
    return () => {
      canceled = true;
    };
  }, [typeName, refreshId]); // get page IDs

  useEffect(() => {
    const getPageIds = async targetPage => {
      // add the `page_ids` to the loading statuses
      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('page_ids');
        return next;
      }); // query for all the draft IDs

      const draftIds = await client.fetch('*[_type == $typeName && _id in path("drafts.**")]._id', {
        typeName
      }); // create a set of drafts IDs.
      // these IDs are used to determine whether or a not a published version
      // should be ignored in order to favor the current draft version

      const drafts = draftIds.reduce((set, next) => {
        set.add(removeDraftPrefix(next));
        return set;
      }, new Set()); // this is a recursive function that will call itself until it reaches the
      // desired page.
      //
      // TODO: this implementation gets slower with each new page. pagination
      // is relatively challenging in this context since there could or could
      // not be a draft. The published version should be ignored to prefer the
      // draft which makes it hard to know where the current page ends and the
      // next one begins

      const getPage = async (start = 0, page = 0) => {
        const end = start + // note: we fetch twice the given page size to consider the cases
        // where we have to remove half the result set in the case of
        // duplicate `draft.` document
        pageSize * 2;
        const pageIds = await client.fetch('*[_type == $typeName][$start...$end]._id', {
          typeName,
          start,
          end
        });
        const filteredIds = pageIds.map((id, index) => ({
          id,
          index: start + index
        })).filter(({
          id
        }) => {
          // if the id is a draft ID, we want to keep it
          if (id.startsWith('drafts.')) return true; // if the published _id exists in `drafts`, then there exists a draft
          // version of the current document and we should prefer that over the
          // published version

          if (drafts.has(id)) return false;
          return true;
        }).slice(0, pageSize);
        const ids = filteredIds.map(i => i.id).map(removeDraftPrefix);
        if (page >= targetPage) return ids;
        const last = filteredIds[filteredIds.length - 1];
        if (!last) return [];
        return await getPage(last.index + 1, page + 1);
      };

      const ids = await getPage(); // delete the `page_ids` from the loading statuses

      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.delete('page_ids');
        return next;
      });
      return ids;
    };

    getPageIds(page).then(setPageIds).catch(e => {
      // TODO: proper error handling
      console.warn(e);
    });
  }, [page, pageSize, typeName, refreshId]); // get results

  useEffect(() => {
    // take all the input IDs and duplicate them with the prefix `drafts.`
    const ids = pageIds.map(id => [id, `drafts.${id}`]).flat(); // these IDs will go into a specific query. if the draft or published
    // version happens to not exist, that's okay.

    const query = `*[_id in $ids] { _id, _type, ${Array.from(selectedColumns).join(', ')} }`;

    async function getResults() {
      // add the `results` to the loading statuses
      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('results');
        return next;
      }); // create a dictionary of indexes where the keys are the IDs and the
      // values are the current index. this dictionary will be used to sort the
      // documents in their original order

      const indexes = pageIds.reduce((acc, id, index) => {
        acc[id] = index;
        return acc;
      }, {});
      const results = await client.fetch(query, {
        ids
      }); // reduce the results into an accumulator by their normalized ID.
      // if there is a draft version, prefer the draft over the published

      const reducedResults = Object.values(results.reduce((acc, next) => {
        const id = removeDraftPrefix(next._id);
        const current = acc[id];
        const currentIsDraft = current === null || current === void 0 ? void 0 : current._id.startsWith('drafts.');
        const nextIsDraft = next === null || next === void 0 ? void 0 : next._id.startsWith('drafts.');
        const status = current && next ? 'draft' : currentIsDraft || nextIsDraft ? 'unpublished' : 'published';
        acc[id] = currentIsDraft ? current : next;
        acc[id]._status = status;
        acc[id]._normalizedId = id;
        return acc;
      }, {})); // delete the `results` from the loading statuses

      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.delete('results');
        return next;
      });
      setResults(reducedResults.slice() // sort the accumulated version by their original index
      .sort((a, b) => indexes[removeDraftPrefix(a._id)] - indexes[removeDraftPrefix(b._id)]));
    } // TODO: consider error handling


    getResults().catch(e => {
      console.warn(e);
    }); // TODO: add error handler

    const subscription = client.listen(query, {
      ids
    }).pipe(tap(() => {
      // add the `results` to the loading statuses
      setLoadingStatuses(prev => {
        const next = new Set(prev);
        next.add('results');
        return next;
      });
    }), debounceTime(1000)).subscribe(getResults);
    return () => subscription.unsubscribe();
  }, [pageIds, selectedColumns, refreshId]); // reset page

  useEffect(() => {
    // if the page is greater than the total pages then reset the page.
    // this could occur if the page size changed
    if (page >= totalPages) {
      setPage(0);
    }
  }, [page, totalPages]);
  return {
    results,
    page,
    totalPages,
    setPage,
    loading,
    pageIds,
    total,
    refresh
  };
}

var css_248z$2 = ".styles-module_list__3zRfK {\n  display: flex;\n  flex-direction: column;\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n}\n\n.styles-module_label__3aTmH {\n  padding: 1rem;\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n}\n\n.styles-module_label__3aTmH:hover {\n  background-color: #f1f3f6;\n}\n\n.styles-module_label__3aTmH:active {\n  background-color: #e4e8ed;\n}\n\n.styles-module_checkbox__2rHDH {\n  margin-right: space(2);\n}\n\n.styles-module_footer__2yt3A {\n  display: flex;\n  gap: 0.5rem;\n  justify-content: flex-end;\n  padding: 0.5rem;\n}\n";
var styles$2 = {"list":"styles-module_list__3zRfK","label":"styles-module_label__3aTmH","checkbox":"styles-module_checkbox__2rHDH","footer":"styles-module_footer__2yt3A"};
styleInject(css_248z$2);

function ColumnSelector({
  open,
  onClose,
  onSelect,
  typeName,
  initiallySelectedColumns
}) {
  const schemaType = schema.get(typeName);
  const [selectedColumns, setSelectedColumns] = useState(initiallySelectedColumns);
  useEffect(() => {
    if (open) {
      setSelectedColumns(initiallySelectedColumns);
    }
  }, [open, initiallySelectedColumns]);
  const dialogId = useMemo(() => nanoid(), []);

  if (!open) {
    return null;
  }

  return /*#__PURE__*/React.createElement(Dialog, {
    className: styles$2.dialog,
    header: /*#__PURE__*/React.createElement(React.Fragment, null, "Select Columns"),
    footer: /*#__PURE__*/React.createElement("div", {
      className: styles$2.footer
    }, /*#__PURE__*/React.createElement(Button, {
      mode: "ghost",
      text: "Cancel",
      onClick: onClose
    }), /*#__PURE__*/React.createElement(Button, {
      tone: "primary",
      text: "Apply",
      onClick: () => {
        onClose();
        onSelect(selectedColumns);
      }
    })),
    id: dialogId,
    onClose: onClose,
    zOffset: 100000
  }, /*#__PURE__*/React.createElement("ul", {
    className: styles$2.list
  }, /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("label", {
    className: styles$2.label
  }, /*#__PURE__*/React.createElement(Checkbox, {
    className: styles$2.checkbox,
    checked: selectedColumns.has('_updatedAt'),
    onChange: () => {
      setSelectedColumns(set => {
        const nextSet = new Set(set);

        if (set.has('_updatedAt')) {
          nextSet.delete('_updatedAt');
        } else {
          nextSet.add('_updatedAt');
        }

        return nextSet;
      });
    }
  }), /*#__PURE__*/React.createElement("span", null, "Updated At"))), schemaType.fields.map(i => {
    const fieldName = i.name;
    const title = i.type.title;
    return /*#__PURE__*/React.createElement("li", {
      key: fieldName
    }, /*#__PURE__*/React.createElement("label", {
      className: styles$2.label
    }, /*#__PURE__*/React.createElement(Checkbox, {
      className: styles$2.checkbox,
      checked: selectedColumns.has(fieldName),
      onChange: () => {
        setSelectedColumns(set => {
          const nextSet = new Set(set);

          if (set.has(fieldName)) {
            nextSet.delete(fieldName);
          } else {
            nextSet.add(fieldName);
          }

          return nextSet;
        });
      }
    }), /*#__PURE__*/React.createElement("span", null, title)));
  })));
}

/**
 * Converts portable text to strings.
 *
 * Copied and pasted from:
 * https://www.sanity.io/docs/presenting-block-text#plain-text-serialization-ac67a867dd69
 */
function blockContentToString(blocks = []) {
  return blocks // loop through each block
  .map(block => {
    // if it's not a text block with children,
    // return nothing
    if (block._type !== 'block' || !block.children) {
      return '';
    } // loop through the children spans, and join the
    // text strings


    return block.children.map(child => child.text).join('');
  }) // join the paragraphs leaving split by two linebreaks
  .join('\n\n');
}

var css_248z$1 = ".styles-module_blockContent__wrT-X {\n  max-width: 300px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n";
var styles$1 = {"blockContent":"styles-module_blockContent__wrT-X"};
styleInject(css_248z$1);

function Cell({
  field,
  value
}) {
  switch (field.type.name) {
    case 'string':
    case 'number':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: field.name
        }, value);
      }

    case 'blockContent':
      {
        const blockContentAsString = blockContentToString(value);
        return /*#__PURE__*/React.createElement("td", {
          title: blockContentAsString,
          key: field.name,
          className: styles$1.blockContent
        }, blockContentAsString);
      }

    case 'datetime':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: field.name
        }, value ? new Date(value).toLocaleString() : '');
      }

    case 'date':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: field.name
        }, value ? new Date(value).toLocaleDateString() : '');
      }

    case 'array':
      {
        return /*#__PURE__*/React.createElement("td", {
          key: field.name
        }, (value === null || value === void 0 ? void 0 : value.length) || 0, " item", (value === null || value === void 0 ? void 0 : value.length) === 1 ? '' : 's');
      }

    default:
      {
        return /*#__PURE__*/React.createElement("td", {
          key: field.name
        }, /*#__PURE__*/React.createElement(SanityPreview, {
          type: field.type,
          layout: "default",
          value: value
        }));
      }
  }
}

var css_248z = "* {\n  box-sizing: border-box;\n}\n\n.styles-module_container__1Lxpd {\n  height: 100%;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.styles-module_tableWrapper__2P76T {\n  flex: 1 1 auto;\n  overflow: auto;\n  position: relative;\n}\n\n.styles-module_loadingOverlay__9jl62 {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  pointer-events: none;\n  transition: opacity 250ms;\n  background-color: white;\n  z-index: 1;\n  opacity: 0;\n  display: flex;\n}\n\n.styles-module_loadingOverlayActive__33Sc2 {\n  opacity: 0.5;\n}\n\n.styles-module_loadingSpinner__1VDlB {\n  margin: auto;\n  width: 32px;\n  height: 32px;\n  -webkit-animation: styles-module_spin__1sp4O 1500ms linear infinite;\n          animation: styles-module_spin__1sp4O 1500ms linear infinite;\n}\n\n@-webkit-keyframes styles-module_spin__1sp4O {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes styles-module_spin__1sp4O {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n.styles-module_table__FnYjQ {\n  border-collapse: collapse;\n  min-width: 100%;\n}\n\n.styles-module_table__FnYjQ td,\n.styles-module_table__FnYjQ th {\n  padding: 0.5rem 1rem;\n  text-align: left;\n}\n\n.styles-module_tbody__1vifL tr td {\n  border-bottom: 1px solid #ced2d9;\n}\n\n.styles-module_thead__1v36c th {\n  padding: 1rem;\n  position: sticky;\n  top: 0;\n  text-align: left;\n  background-color: white;\n  z-index: 1;\n}\n\n.styles-module_tbody__1vifL td {\n  cursor: pointer;\n}\n\n.styles-module_thead__1v36c th::after {\n  position: absolute;\n  content: ' ';\n  left: 0;\n  right: 0;\n  bottom: 0;\n  top: 0;\n  border-bottom: 2px solid #ced2d9;\n  pointer-events: none;\n}\n\n.styles-module_tbody__1vifL tr:hover td {\n  background-color: #f1f3f6;\n}\n\n.styles-module_tbody__1vifL tr:active td {\n  background-color: #e4e8ed;\n}\n\n.styles-module_footer__24OKz {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  gap: 1rem;\n  padding: 0.5rem;\n  border-top: 2px solid #ced2d9;\n}\n\n.styles-module_selectLabel__2PSG4 {\n  display: flex;\n  gap: 1rem;\n  align-items: center;\n}\n\n.styles-module_select__1ul-b {\n  width: 75px;\n}\n\n.styles-module_table__FnYjQ .styles-module_optionsCell__2-oPN {\n  text-align: right;\n}\n\n.styles-module_menu__1QRAq {\n  text-align: left;\n}\n\n.styles-module_table__FnYjQ .styles-module_titleCell__39gLv {\n  max-width: 232px;\n  padding-left: 0;\n}\n\n.styles-module_checkboxCell__3-B6e {\n  width: 30px;\n  overflow: hidden;\n  position: relative;\n}\n\n.styles-module_hiddenCheckbox__2-oXU {\n  height: 100%;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  left: 0;\n  width: 100%;\n  opacity: 0;\n  cursor: pointer;\n}\n\n.styles-module_checkboxFacade__Ge5qx {\n  display: flex;\n  pointer-events: none;\n}\n\n.styles-module_checkboxCell__3-B6e > * > * {\n  margin: auto;\n}\n\n.styles-module_bulkInfo__g1bxk {\n  flex: 0 0 auto;\n  background-color: black;\n  color: white;\n  padding: 0 0.5rem;\n  top: 0;\n  height: 0;\n  overflow: hidden;\n  transition-duration: 250ms;\n  transition-property: height, opacity;\n  opacity: 0;\n  display: flex;\n}\n\n.styles-module_bulkInfo__g1bxk > * {\n  margin: auto;\n}\n\n.styles-module_bulkInfoRevealed__4aq7d {\n  height: 32px;\n  opacity: 1;\n}\n\n.styles-module_bulkInfoContainer__2EMjO {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.styles-module_clearButton__Z9ota {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  outline: none;\n  background: none;\n  border: none;\n  color: inherit;\n  cursor: pointer;\n}\n\n.styles-module_clearButton__Z9ota:hover,\n.styles-module_clearButton__Z9ota:focus {\n  text-decoration: underline;\n}\n\n.styles-module_clearButton__Z9ota:active {\n  color: #ddd;\n}\n\n.styles-module_statusIcon__3_ptG {\n  width: 24px;\n  height: 24px;\n}";
var styles = {"container":"styles-module_container__1Lxpd","tableWrapper":"styles-module_tableWrapper__2P76T","loadingOverlay":"styles-module_loadingOverlay__9jl62","loadingOverlayActive":"styles-module_loadingOverlayActive__33Sc2","loadingSpinner":"styles-module_loadingSpinner__1VDlB","spin":"styles-module_spin__1sp4O","table":"styles-module_table__FnYjQ","tbody":"styles-module_tbody__1vifL","thead":"styles-module_thead__1v36c","footer":"styles-module_footer__24OKz","selectLabel":"styles-module_selectLabel__2PSG4","select":"styles-module_select__1ul-b","optionsCell":"styles-module_optionsCell__2-oPN","menu":"styles-module_menu__1QRAq","titleCell":"styles-module_titleCell__39gLv","checkboxCell":"styles-module_checkboxCell__3-B6e","hiddenCheckbox":"styles-module_hiddenCheckbox__2-oXU","checkboxFacade":"styles-module_checkboxFacade__Ge5qx","bulkInfo":"styles-module_bulkInfo__g1bxk","bulkInfoRevealed":"styles-module_bulkInfoRevealed__4aq7d","bulkInfoContainer":"styles-module_bulkInfoContainer__2EMjO","clearButton":"styles-module_clearButton__Z9ota","statusIcon":"styles-module_statusIcon__3_ptG"};
styleInject(css_248z);

function parentHasClass(el, className) {
  if (!el) return false;
  if (el.classList.contains(className)) return true;
  return parentHasClass(el.parentElement, className);
}

function createSuperPane(typeName, S) {
  const schemaType = schema.get(typeName);
  const selectColumns = createEmitter();
  const refresh = createEmitter();

  function SuperPane() {
    const router = useRouter();
    const [pageSize, setPageSize] = useState(25);
    const [columnSelectorOpen, setColumnSelectorOpen] = useState(false);
    const [selectedColumns, setSelectedColumns] = useState(new Set());
    const [selectedIds, setSelectedIds] = useState(new Set());
    const containerRef = useRef(null);
    const client = usePaginatedClient({
      typeName,
      pageSize,
      selectedColumns
    });
    useEffect(() => {
      return selectColumns.subscribe(() => setColumnSelectorOpen(true));
    }, []);
    useEffect(() => {
      return refresh.subscribe(client.refresh);
    }, [client.refresh]);
    const fields = schemaType.fields.filter(field => selectedColumns.has(field.name));
    const atLeastOneSelected = client.results.some(i => selectedIds.has(i._normalizedId));
    const allSelected = client.results.every(i => selectedIds.has(i._normalizedId));
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
      ref: containerRef,
      className: styles.container
    }, /*#__PURE__*/React.createElement("div", {
      className: classNames(styles.bulkInfo, {
        [styles.bulkInfoRevealed]: selectedIds.size > 0
      })
    }, /*#__PURE__*/React.createElement("div", {
      className: styles.bulkInfoContainer
    }, /*#__PURE__*/React.createElement(Label, null, selectedIds.size, " item", selectedIds.size === 1 ? '' : 's', ' ', "selected"), /*#__PURE__*/React.createElement("button", {
      className: styles.clearButton,
      onClick: () => setSelectedIds(new Set())
    }, /*#__PURE__*/React.createElement(Label, null, "Clear")), /*#__PURE__*/React.createElement(BulkActionsMenu, {
      className: styles.clearButton,
      selectedIds: selectedIds,
      typeName: typeName
    }))), /*#__PURE__*/React.createElement("div", {
      className: styles.tableWrapper
    }, /*#__PURE__*/React.createElement("div", {
      className: classNames(styles.loadingOverlay, {
        [styles.loadingOverlayActive]: client.loading
      })
    }, /*#__PURE__*/React.createElement(SpinnerIcon, {
      className: styles.loadingSpinner
    })), /*#__PURE__*/React.createElement("table", {
      className: styles.table
    }, /*#__PURE__*/React.createElement("thead", {
      className: styles.thead
    }, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("th", {
      className: classNames(styles.checkboxCell, 'prevent-nav')
    }, /*#__PURE__*/React.createElement("input", {
      type: "checkbox",
      className: styles.hiddenCheckbox,
      onChange: () => {
        setSelectedIds(set => {
          const nextSet = new Set(set);

          if (allSelected) {
            for (const result of client.results || []) {
              nextSet.delete(result._normalizedId);
            }
          } else {
            for (const result of client.results || []) {
              nextSet.add(result._normalizedId);
            }
          }

          return nextSet;
        });
      },
      checked: allSelected
    }), /*#__PURE__*/React.createElement("div", {
      "aria-hidden": "true",
      className: styles.checkboxFacade
    }, /*#__PURE__*/React.createElement(Checkbox, {
      tabIndex: -1,
      checked: atLeastOneSelected,
      indeterminate: atLeastOneSelected && !allSelected
    }))), /*#__PURE__*/React.createElement("th", null, /*#__PURE__*/React.createElement(Label, null, schemaType.title)), /*#__PURE__*/React.createElement("th", null, /*#__PURE__*/React.createElement(Label, null, "Status")), selectedColumns.has('_updatedAt') && /*#__PURE__*/React.createElement("th", null, /*#__PURE__*/React.createElement(Label, null, "Updated At")), fields.map(field => /*#__PURE__*/React.createElement("th", {
      key: field.name
    }, /*#__PURE__*/React.createElement(Label, null, field.type.title))), /*#__PURE__*/React.createElement("th", {
      className: styles.optionsCell,
      "aria-label": "Options"
    }))), /*#__PURE__*/React.createElement("tbody", {
      className: styles.tbody
    }, client.results.map(item => {
      const handleNavigation = () => {
        router.navigateUrl(router.resolveIntentLink('edit', {
          id: item._id,
          type: item._type
        }));
      };

      return /*#__PURE__*/React.createElement("tr", {
        key: item._normalizedId,
        onClick: e => {
          // prevent the menu button from causing a navigation
          if (parentHasClass(e.target, 'prevent-nav')) {
            return;
          }

          handleNavigation();
        }
      }, /*#__PURE__*/React.createElement("td", {
        className: classNames(styles.checkboxCell, 'prevent-nav')
      }, /*#__PURE__*/React.createElement("input", {
        type: "checkbox",
        className: styles.hiddenCheckbox,
        onChange: e => {
          setSelectedIds(set => {
            const nextSet = new Set(set);

            if (e.currentTarget.checked) {
              nextSet.add(item._normalizedId);
            } else {
              nextSet.delete(item._normalizedId);
            }

            return nextSet;
          });
        },
        checked: selectedIds.has(item._normalizedId)
      }), /*#__PURE__*/React.createElement("div", {
        "aria-hidden": "true",
        className: styles.checkboxFacade
      }, /*#__PURE__*/React.createElement(Checkbox, {
        tabIndex: -1,
        checked: selectedIds.has(item._normalizedId)
      }))), /*#__PURE__*/React.createElement("td", {
        className: styles.titleCell
      }, /*#__PURE__*/React.createElement(SanityPreview, {
        type: schemaType,
        layout: "default",
        value: item
      })), /*#__PURE__*/React.createElement("td", null, /*#__PURE__*/React.createElement(Badge, {
        size: 1,
        tone: item._status === 'published' ? 'positive' : item._status === 'unpublished' ? 'caution' : 'default'
      }, item._status)), selectedColumns.has('_updatedAt') && /*#__PURE__*/React.createElement("td", null, new Date(item._updatedAt).toLocaleString()), fields.map(field => /*#__PURE__*/React.createElement(Cell, {
        field: field,
        value: item[field.name]
      })), /*#__PURE__*/React.createElement("td", {
        className: styles.optionsCell
      }, /*#__PURE__*/React.createElement(MenuButton, {
        button: /*#__PURE__*/React.createElement(Button, {
          className: "prevent-nav",
          icon: EllipsisVerticalIcon,
          title: "Options",
          mode: "bleed"
        }),
        portal: true,
        id: "prevent-nav-example",
        menu: /*#__PURE__*/React.createElement(Menu, {
          className: styles.menu
        }, /*#__PURE__*/React.createElement(MenuItem, {
          className: "prevent-nav",
          text: "Open",
          icon: ArrowRightIcon,
          onClick: handleNavigation
        })),
        placement: "left"
      })));
    })))), /*#__PURE__*/React.createElement("div", {
      className: styles.footer
    }, /*#__PURE__*/React.createElement("label", {
      className: styles.selectLabel
    }, /*#__PURE__*/React.createElement(Label, null, "Rows Per Page"), /*#__PURE__*/React.createElement("div", {
      className: styles.select
    }, /*#__PURE__*/React.createElement(Select, {
      value: pageSize,
      onChange: e => setPageSize(parseInt(e.currentTarget.value, 10))
    }, /*#__PURE__*/React.createElement("option", {
      value: 25
    }, "25"), /*#__PURE__*/React.createElement("option", {
      value: 50
    }, "50"), /*#__PURE__*/React.createElement("option", {
      value: 100
    }, "100")))), /*#__PURE__*/React.createElement(Button, {
      fontSize: 1,
      disabled: client.page === 0,
      onClick: () => client.setPage(client.page - 1),
      icon: ChevronLeftIcon,
      title: "Previous page",
      mode: "bleed"
    }), /*#__PURE__*/React.createElement(Label, null, client.page + 1, "\xA0/\xA0", client.totalPages), /*#__PURE__*/React.createElement(Button, {
      fontSize: 1,
      disabled: client.page >= client.totalPages - 1,
      onClick: () => client.setPage(client.page + 1),
      icon: ChevronRightIcon,
      title: "Next Page",
      mode: "bleed"
    }))), /*#__PURE__*/React.createElement(ColumnSelector, {
      open: columnSelectorOpen,
      onClose: () => setColumnSelectorOpen(false),
      typeName: typeName,
      initiallySelectedColumns: selectedColumns,
      onSelect: setSelectedColumns
    }));
  }

  function SuperPaneWrapper() {
    return /*#__PURE__*/React.createElement(RouterProvider, null, /*#__PURE__*/React.createElement(SuperPane, null));
  }

  return Object.assign(S.documentTypeList(typeName).serialize(), {
    type: 'component',
    component: SuperPaneWrapper,
    menuItems: S.documentTypeList(typeName).menuItems([S.menuItem().title('Refresh').icon(SyncIcon).action(refresh.notify), S.menuItem().title('Select Columns').icon(ControlsIcon).action(selectColumns.notify)]).serialize().menuItems
  });
}

export { createSuperPane };
//# sourceMappingURL=index.esm.js.map
